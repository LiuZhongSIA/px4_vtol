EKF2采用Estimation and Control Library（.../src/lib/ecl/EKF）中的EKF进行姿态与位置解算

EKF所需要的参数，定义于common.h中的结构体“parameters”
所要解算的状态，定义于common.h中的结构体“stateSample”中，包含四元数（4）、NED速度（3）、NED位置（3）、陀螺偏差（3）、加速度偏差（3）、NED磁场（3）、磁力计偏差（3）、风速（2），共24个状态
采用的传感器信息包括：陀螺仪（直接使用陀螺积分）、加速度计（直接使用加速度积分，可选择不估计加速度偏差，见参数EKF2_AID_MASK）、GPS（直接使用转换到NED下的位置信息）、磁罗盘、气压计（高度信息可以选择多种来源，见参数EKF2_HGT_MODE）、测距仪、光流、风速管、视觉（可以时动捕信息）等

线程EKF2中的功能比较简单，填入传感器数据，EKF更新，读取EKF估计值——
1. _ekf.setIMUData更新IMU信息：使用陀螺积分，相当于姿态变化值；使用了加速度积分，相当于速度变化量
setIMUData(...)定义在estimator_interface.cpp中，这是EKF的父类。此函数中，进行了_ekf的初始化，估计状态值置0，预处理后，将IMU信息放入缓存区_imu_buffer，并获得缓存区最旧的数据_imu_sample_delayed
2. _ekf.setMagData更新磁罗盘信息，_ekf.setBaroData更新气压计信息
3. _ekf.setGpsData更新GPS信息，setGpsData(...)定义在estimator_interface.cpp中，信息填入缓存区_gps_buffer
函数中，collect_gps(...)函数会进行GPS的初始化，至少需要10s的初始化时间，定义于gps_checks.cpp中，初始化后，才能将经纬高信息转化为NED信息
4. _ekf.setAirspeedData、_ekf.setOpticalFlowData、_ekf.setExtVisionData更新风速、光流、视觉数据，存入对应缓存区
5. _ekf.update()实现EKF的全部功能，下面会详细介绍
6. 通过_ekf.get_...(...)函数们，获得非延时域速度、位置、四元数（隐含一个互补滤波器），以及延时域下的传感器偏差等（EKF实现）

EKF初始化——
EKF2直接调用了ekf.cpp中的update()函数，首先使用函数initialiseFilter()进行EKF的初始化
使用IMU的加速度积分和进行姿态四元数的初始化，进行高度的初始化，_state是延时域EKF状态
函数initialiseCovariance()对状态协方差阵进行更新，函数定义在covariance.cpp中，采用测量噪声等设置参数进行初始化
_output_buffer中存放的是非延时域的状态，其初始化在函数alignOutputFilter()中实现，在ekf_helper.cpp中
_state初始化时，使用的就是_imu_sample_delayed以及比这数据还要旧的其他传感器信息
关于_state的EKF估计是在延时域上进行的

EKF预测更新——
预测更新使用的ekf.cpp中的函数predictState()：
首先，获得陀螺测量的旋转角度，将其转化为四元数，对当前姿态四元数进行旋转（Δq×q），作为四元数的预估值；
之后，加速度积分，对于速度进行更新，作为速度预估值；
位置预估值直接根据上一周期的速度和速度预估值获得
注意：姿态和位置的预测更新使用的都是延时域的测量值_imu_sample_delayed，系统的状态方程输入为陀螺积分和加速度积分（注意重力的影响）
预测更新后，使用函数predictCovariance()进行协方差阵的更新：
函数定义在covariance.cpp中，标准的EKF估计协方差采用 P_=F*P*F^T+Q，F是非线性系统状态方程相对于状态的雅可比矩阵，Q是测量噪声协方差阵
但是，过程没看懂，比较复杂的代码实现，应该是上述原理
注意：根据地面的设置，协方差阵的部分是不进行更新的，因为一些状态可能不会进行估计，比如加速度偏差，不更新的部分会直接赋值为上一时刻的值，且不受到过程噪声的影响
注意：地面站设置的过程噪声标准差都是对于连续系统而言的，EKF所面对的是离散系统，需要将地面站的设置值*dt

EKF测量更新——
Pix可以搭载多个具有类似功能的传感器，例如气压计和视觉都可以进行飞行高度测量，那么对于测量数据融合之前就需要对融合操作进行合理地控制
controlFusionModes()定义在control.cpp，会根据设置与传感器的实际状态进行融合控制
（1）磁罗盘、视觉具有航向信息，标志位 _control_status.flags.ev_yaw、_control_status.flags.mag_hdg、_control_status.flags.mag_3D
     磁罗盘可以实现与视觉一样的航向融合 fuseHeading()，也可以实现3D融合 fuseMag()（in mag_fusion.cpp）
（2）视觉、GPS具有平面位置信息，标志位 _control_status.flags.ev_pos、_control_status.flags.gps
     仅GPS由平面速度，根据标志位不同，融合采用 fuseVelPosHeight()（in vel_pos_fusion.cpp）
（3）气压计、GPS、测距仪、视觉具有垂向位置信息，标志位 _control_status.flags.baro_hgt、_control_status.flags.gps_hgt、_control_status.flags.rng_hgt、_control_status.flags.ev_hgt
     仅GPS有垂向速度，同样根据标志位不同，融合采用 fuseVelPosHeight()（in vel_pos_fusion.cpp）
（4）光流可以获取位置信息和航向信息，标志位 _control_status.flags.opt_flow，融合采用 calcOptFlowBias()、fuseOptFlow()（in optflow_fusion.cpp）
（5）风速管和侧划角包含风速信息，标志位 _control_status.flags.wind、_control_status.flags.fuse_beta，融合采用 resetWindStates()、resetWindCovariance()、fuseAirspeed()、fuseSideslip()（in airspeed_fusion.cpp and sideslip_fusion.cpp）
上面的5个文件分别进行不同状态的测量更新，进行顺序是“姿态”、“风速”、“位置”
mag_fusion.cpp：
fuseMag()进行3D磁场信息融合，可以测量更新系统状态 mag_I 和 mag_B，以及四元数
END三个方向的雅可比矩阵与Kalman增益分别计算，使用三个测量值进行更新
fuseDeclination()进行磁偏角的融合，要配合上面这个函数使用，用于更新系统状态 mag_I 和 mag_B
fuseHeading()仅融合航向信息，通过磁罗盘或者视觉信息测量获得航向测量值，并且测量值已经经过了磁偏角的补偿
optflow_fusion.cpp：

airspeed_fusion.cpp：

sideslip_fusion.cpp：

vel_pos_fusion.cpp：


延时域～非延时域——
上述EKF过程是在延时域进行的状态估计与数据融合，需要进一步修正延时的影响，函数calculateOutputStates()进行了这个过程
使用最新IMU数据的姿态变化量，对 _output_new（最新的数据）的四元数进行旋转；使用IMU的速度变化数据，对 _output_new 的速度和位置信息进行补偿
再计算对于 _output_buffer 所有位置和速度的补偿量
参考文献：Recursive Attitude Estimation in the Presence of Multi-rate and Multi-delay Vector Measurements

单独的地形KF——
代码在terrain_estimator.cpp中
地形垂向位置=-地形高度=距地高度-起飞高度=距地高度+飞机D位置
初始化函数initHagl()：
成功的初始化需要较新的距离传感器信息，且距离传感器测得是直线距离l，l*cos(phi)*cos(theta)才是距地距离
预测函数predictHagl()：
系统状态方程为Tv(k+1)=Tv(k)+w(k)，假设了地面高度慢变，只受噪声驱动
关键是要更新估计协方差，考虑了过程噪声协方差以及地形梯度的影响
测量更新函数fuseHagl()：
测量方程yT=Tv-xD，可以根据预估状态以及测量值生成新息（innovation）
观测噪声的协方差阵包含了测距仪的测量噪声以及垂向位置的协方差
KF生成地形估计值_terrain_vpos以及协方差阵_terrain_var
